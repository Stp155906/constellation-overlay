# -*- coding: utf-8 -*-
"""constellationoverlay.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i0_aSAeLnEKwYFWSCdo04GS75QlnK462
"""

#!/usr/bin/env python3
"""
ConstellationOverlay — GitHub-ready generator (no previews)

Generates an overlay JSON that places each IAU constellation at the Earth
sub-point (directly-overhead point) for a given UTC snapshot.

- Centers = true Earth sub-points at the chosen snapshot time
  (lat = declination; lon = (RA - GST)*15° normalized to [-180,180]).
- Optional asterisms block with the same placement logic.
- Pure CLI tool.

Usage examples:
  python constellationoverlay.py
  python constellationoverlay.py --snapshot-utc 2025-10-10T03:00:00Z --include-asterisms
  python constellationoverlay.py --ra-step 6 --dec-step 6 --out out/overlay.json

Dependencies:
  pip install astropy numpy
"""

from __future__ import annotations
import argparse, json, math, os
from datetime import datetime, timezone
from typing import Dict, List, Tuple
import numpy as np
import astropy.units as u
from astropy.coordinates import SkyCoord, get_constellation
from astropy.time import Time

# ---------------------------- Defaults ----------------------------

STAR_DOTS_BRIGHT = [
    {"latitude":  7.0, "longitude": -72.0},
    {"latitude": 21.0, "longitude": -33.0},
    {"latitude": -5.0, "longitude":  14.0},
]

# Asterism definitions (ICRS RA/Dec for key component stars)
ASTERISMS_DEF = [
    {"name":"Orion's Belt","parent":"Orion","kind":"line",
     "components_icrs_deg":[(83.0017,-0.2991),(84.0534,-1.2019),(85.1897,-1.9426)]},
    {"name":"Pleiades","parent":"Taurus","kind":"cluster",
     "components_icrs_deg":[(56.8711,24.1052),(56.75,24.2),(56.95,24.0)]},
    {"name":"Big Dipper","parent":"Ursa Major","kind":"line",
     "components_icrs_deg":[(165.460,61.751),(165.931,56.382),(178.457,53.694),
                            (183.856,57.032),(193.507,55.959),(200.981,54.925),(206.885,49.313)]},
    {"name":"Summer Triangle","parent":"Aquila/Lyra/Cygnus","kind":"triangle",
     "components_icrs_deg":[(279.2347,38.7837),(310.3579,45.2803),(297.6958,8.8683)]},
    {"name":"Northern Cross","parent":"Cygnus","kind":"line",
     "components_icrs_deg":[(310.3579,45.2803),(305.557,40.2567),(292.68,33.9670)]},
]

# ---------------------------- Helpers -----------------------------

def iso_z(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).isoformat().replace("+00:00","Z")

def parse_snapshot(s: str | None) -> datetime:
    if not s:
        return datetime.now(timezone.utc)
    return datetime.fromisoformat(s.replace("Z","+00:00")).astimezone(timezone.utc)

def sky_grid_icrs(ra_step_deg: float, dec_step_deg: float, dec_min_deg: float, dec_max_deg: float) -> SkyCoord:
    ras  = np.arange(0.0, 360.0 + 1e-9, ra_step_deg)
    decs = np.arange(dec_min_deg, dec_max_deg + 1e-9, dec_step_deg)
    RA, DEC = np.meshgrid(ras, decs)
    return SkyCoord(ra=RA.flatten()*u.deg, dec=DEC.flatten()*u.deg, frame="icrs")

def mean_radec_deg(points: List[Tuple[float,float]]) -> Tuple[float,float]:
    ra = np.radians([p[0] for p in points])
    dec = np.radians([p[1] for p in points])
    x = np.cos(dec)*np.cos(ra); y = np.cos(dec)*np.sin(ra); z = np.sin(dec)
    x_m, y_m, z_m = np.mean(x), np.mean(y), np.mean(z)
    r = (x_m*x_m + y_m*y_m + z_m*z_m) ** 0.5
    x_m, y_m, z_m = x_m/r, y_m/r, z_m/r
    ra_c  = (np.degrees(np.arctan2(y_m, x_m)) + 360.0) % 360.0
    dec_c = np.degrees(np.arcsin(z_m))
    return float(ra_c), float(dec_c)

def constellation_centroids(ra_step_deg: float, dec_step_deg: float, dec_min_deg: float, dec_max_deg: float) -> Dict[str,Tuple[float,float]]:
    grid = sky_grid_icrs(ra_step_deg, dec_step_deg, dec_min_deg, dec_max_deg)
    labels = [get_constellation(pt) for pt in grid]
    buckets: Dict[str, List[int]] = {}
    for i, nm in enumerate(labels):
        buckets.setdefault(nm.strip(), []).append(i)
    cents: Dict[str,Tuple[float,float]] = {}
    for nm, idxs in buckets.items():
        pts = [(float(grid.ra[i].degree), float(grid.dec[i].degree)) for i in idxs]
        cents[nm] = mean_radec_deg(pts)
    return cents

def subpoint_for_ra_dec(ra_deg: float, dec_deg: float, snapshot_utc: datetime):
    t = Time(snapshot_utc)
    gst_hours = float(t.sidereal_time("mean","greenwich").hour)
    lon = ((ra_deg/15.0 - gst_hours) * 15.0 + 180.0) % 360.0 - 180.0
    lat = dec_deg
    return float(lat), float(lon)

# --------------------------- Generator ----------------------------

def build_overlay(snapshot_utc: datetime, ra_step_deg: float, dec_step_deg: float, dec_min_deg: float, dec_max_deg: float,
                  base_radius_m: float, alt_scale_m_per_deg: float, include_asterisms: bool) -> dict:
    cents = constellation_centroids(ra_step_deg, dec_step_deg, dec_min_deg, dec_max_deg)
    items = []
    for name, (ra_deg, dec_deg) in cents.items():
        lat, lon = subpoint_for_ra_dec(ra_deg, dec_deg, snapshot_utc)
        radius_m = base_radius_m + alt_scale_m_per_deg * 60.0
        items.append({
            "name": name,
            "center": {"latitude": lat, "longitude": lon},
            "radiusMeters": radius_m,
            "meta": {"visibilityTonight": {
                "visible": True, "max_alt_deg": 90.0, "max_alt_time_utc": iso_z(snapshot_utc),
                "zenith_sep_deg": 0.0, "hours_local": []
            }}
        })
    payload = {
        "version": "overlay.v1",
        "generated_at_utc": iso_z(snapshot_utc),
        "items": sorted(items, key=lambda it: it["center"]["longitude"]),
        "starDots": {"bright": STAR_DOTS_BRIGHT}
    }
    if include_asterisms:
        ast_items = []
        for a in ASTERISMS_DEF:
            ra_c, dec_c = mean_radec_deg(a["components_icrs_deg"])
            lat, lon = subpoint_for_ra_dec(ra_c, dec_c, snapshot_utc)
            ast_items.append({
                "name": a["name"],
                "parent": a["parent"],
                "kind": a["kind"],
                "center": {"latitude": lat, "longitude": lon},
                "meta": {"visibilityTonight": {
                    "visible": True, "hours_local": [], "max_alt_deg": 90.0,
                    "max_alt_time_utc": iso_z(snapshot_utc), "zenith_sep_deg": 0.0
                }}
            })
        payload["asterisms"] = sorted(ast_items, key=lambda it: it["center"]["longitude"])
    return payload

# ----------------------------- Main -------------------------------

def main():
    ap = argparse.ArgumentParser(description="Generate constellation overlay JSON (Earth sub-points).")
    ap.add_argument("--snapshot-utc", type=str, default=None, help="UTC like 2025-10-10T03:00:00Z (default: now)")
    ap.add_argument("--ra-step", type=float, default=8.0)
    ap.add_argument("--dec-step", type=float, default=8.0)
    ap.add_argument("--dec-min", type=float, default=-80.0)
    ap.add_argument("--dec-max", type=float, default=80.0)
    ap.add_argument("--base-radius", type=float, default=300_000.0)
    ap.add_argument("--alt-scale", type=float, default=5_000.0)
    ap.add_argument("--include-asterisms", action="store_true")
    ap.add_argument("--out", type=str, default="out/overlay.json")
    args = ap.parse_args()

    snapshot_utc = parse_snapshot(args.snapshot_utc)
    payload = build_overlay(snapshot_utc, args.ra_step, args.dec_step, args.dec_min, args.dec_max,
                            args.base_radius, args.alt_scale, args.include_asterisms)

    out_path = args.out
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "w") as f:
        json.dump(payload, f, indent=2)
    print(f"✅ wrote {out_path} at {payload['generated_at_utc']}")

if __name__ == "__main__":
    main()